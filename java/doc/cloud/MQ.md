# MQ

> 异步通信

## 初识 MQ

### 事件驱动

> broker

- 优点
  - 低耦合
  - 吞吐量上升
    - 某些事件需要做的事情变少
  - 故障隔离
  - 流量削峰
- 缺点
  - 依赖 broker
  - 不好追踪管理

### 什么是 MQ(broker)

> 消息队列

- 市场上有多种 MQ 的解决方案

  - 各自有不同的性能处理情况

- 发布者
- 中间人
  - 通道
  - 队列
  - 分组
    - 权限
    - 虚拟 host
- 订阅者

### SpringAMQP

> 主要是简化 RabbitMQ 原生写法

- 基本用法

  - 通过配置文件和@AutoWrite 之后, 可以很优雅的处理发送消息
  - 监听消息通过 `@RabbitListener(queue = 'name')`
    - 注意最上面要加上 @Component
    - 方法内部接受消息
    - 无法回溯

- 一个发布者 两个消费者

  > 提高消息处理效率

  - 通过配置可以控制获取发布消息的内容

- 存在 `exchange`(交换机)
  > 队列和交换机之间需要进行绑定
  - Fanout(广播)
    - 一个发布, 每个消费者都能接收到
  - Direct(路由)
    - 发布到指定的消费者
    - 每次发送需要一个 `bindingKey`
  - Topic(话题)
    - 存在通配符,进行规则绑定
    - 其它的和 Direct 一般无二

### 消息转换器

> MQ 发送的消息是一个 Object 类型, 可以很多样化,

- 注意: 可以自己进行一个内容的解析和获取

## 高级特性

### mq 的一些常见问题

- mq 发送的消息至少要消费一次(可靠性)
  - 配置文件配置, auto
    - 如果 mq 发送失败会重新发送
      - 可以通过配置更爱重新发送的逻辑
- 延迟性(一个小时之后处理)
- 消息堆积问题(百万消息堆积)
- 高可用(单点突破)

### 消息的可靠性

- 消息的丢失
  - 整个消息流程中某一个环节出了问题
- 解决方案
  - 所有的执行流程最终都会触发我自定义的回调
    - 这个回调我可以进行一些没有成功的处理啥的, 完成了处理什么的
  - 消息持久化
    - 我发送的 mq 消息 不会因为 服务器的关闭 而消息, 知道发送完成闭环之后才会

### 死信交换机

> 没有消费者使用的消息, 过多的消息, 过期的消息 会加入到 `死信交换机`

- ttl 实现 `延迟性`

  - 主流程中设置一个 超时加入 死信队列的操作
  - 消费者监听死信交换机 队列里面的内容

- 有些插件可以做到 延迟操作的功能
  - `delay exchange`
    - 增强 mq 微服务的功能
    - 通过手段, 加入到原本的 mq 服务中去

### 消息堆积问题

- 解决思路

  - 增加消费者
  - 消费者内开启线程池 加快消息处理速度
  - 扩大对垒容积, 提高堆积上限

- 惰性队列
  - 队列保存的数据, 直接保存到磁盘中去

### mq 集群

- 普通集群
  - 所有集群之间公用 队列数据
  - 如果有一个集群 炸了, 没有办法数据丢失
- 镜像集群

  - 所有数据互相备份
  - 少部分集群坏了, 没有关系

- 仲裁队列
  - 同镜像集群一样的数据保存
  - 使用简单(内部自己定义好了)
  - 一个主 四个从节点
  - 数据保持强一致
